use async_trait::async_trait;
use std::path::{Path, PathBuf, Component};
use tokio::fs;
use chrono::{DateTime, Local};
use std::env;

use super::{Driver, FileInfo, DriverFactory, DriverInfo};

pub struct LocalDriver {
    pub root: PathBuf,
}

impl LocalDriver {
    fn normalize_path(&self, path: &str) -> anyhow::Result<PathBuf> {
        // ÁßªÈô§ÂºÄÂ§¥ÁöÑÊñúÊù†Âπ∂ËßÑËåÉÂåñË∑ØÂæÑÂàÜÈöîÁ¨¶
        let path = path.trim_start_matches('/').replace('\\', "/");
        
        // Â§ÑÁêÜ .. Âíå . Á≠âÁâπÊÆäË∑ØÂæÑÁªÑ‰ª∂
        let mut normalized = PathBuf::new();
        for component in Path::new(&path).components() {
            match component {
                Component::ParentDir => {
                    if normalized.parent().is_some() {
                        normalized.pop();
                    }
                },
                Component::Normal(name) => normalized.push(name),
                Component::CurDir => {},
                _ => {},
            }
        }
        
        let full_path = self.root.join(normalized);
        
        // Ëé∑ÂèñËßÑËåÉÂåñÁöÑÊ†πË∑ØÂæÑ
        let canonical_root = match self.root.canonicalize() {
            Ok(r) => r,
            Err(_) => {
                // Â¶ÇÊûúÊ†πÁõÆÂΩï‰∏çÂ≠òÂú®ÔºåÂàõÂª∫ÂÆÉ
                std::fs::create_dir_all(&self.root)?;
                self.root.canonicalize()?
            }
        };
        
        // Ê£ÄÊü•ÁõÆÊ†áË∑ØÂæÑÊòØÂê¶Âú®Ê†πÁõÆÂΩï‰∏ã
        let target_path = if full_path.exists() {
            full_path.canonicalize()?
        } else {
            full_path.clone()
        };
        
        if !target_path.starts_with(&canonical_root) {
            return Err(anyhow::anyhow!("ËÆøÈóÆË∑ØÂæÑË∂ÖÂá∫Ê†πÁõÆÂΩïËåÉÂõ¥"));
        }
        
        Ok(full_path)
    }
    
    fn ensure_dir_exists(&self, path: &Path) -> anyhow::Result<()> {
        if !path.exists() {
            std::fs::create_dir_all(path)?;
        }
        Ok(())
    }
}

#[async_trait]
impl Driver for LocalDriver {
    async fn move_file(&self, _file_path: &str, _new_parent_path: &str) -> anyhow::Result<()> {
        Err(anyhow::anyhow!("Êú¨Âú∞È©±Âä®‰∏çÊîØÊåÅÁßªÂä®Êìç‰Ωú"))
    }

    async fn copy_file(&self, _file_path: &str, _new_parent_path: &str) -> anyhow::Result<()> {
        Err(anyhow::anyhow!("Êú¨Âú∞È©±Âä®‰∏çÊîØÊåÅÂ§çÂà∂Êìç‰Ωú"))
    }

    async fn list(&self, path: &str) -> anyhow::Result<Vec<FileInfo>> {
        let full_path = self.normalize_path(path)?;
        let mut entries = fs::read_dir(full_path).await?;
        let mut files = Vec::new();

        while let Some(entry) = entries.next_entry().await? {
            let metadata = entry.metadata().await?;
            let name = entry.file_name().to_string_lossy().to_string();
            let is_dir = metadata.is_dir();
            let size = if is_dir { 0 } else { metadata.len() };
            let modified = metadata.modified()
                .map(|time| {
                    let datetime: DateTime<Local> = time.into();
                    datetime.to_rfc3339()
                })
                .unwrap_or_else(|_| chrono::Utc::now().to_rfc3339());

            let file_path = if path.is_empty() {
                name.clone()
            } else {
                format!("{}/{}", path, name)
            };

            files.push(FileInfo {
                name,
                path: file_path,
                size,
                is_dir,
                modified,
            });
        }

        Ok(files)
    }

    async fn download(&self, path: &str) -> anyhow::Result<tokio::fs::File> {
        let full_path = self.normalize_path(path)?;
        let file = tokio::fs::File::open(full_path).await?;
        Ok(file)
    }

    async fn get_download_url(&self, _path: &str) -> anyhow::Result<Option<String>> {
        // Êú¨Âú∞È©±Âä®‰∏çÈúÄË¶ÅÁâπÊÆäÁöÑ‰∏ãËΩΩURL
        Ok(None)
    }

    async fn upload_file(&self, parent_path: &str, file_name: &str, content: &[u8]) -> anyhow::Result<()> {
        let dir_path = if parent_path.is_empty() {
            self.root.clone()
        } else {
            self.normalize_path(parent_path)?
        };
        
        tokio::fs::create_dir_all(&dir_path).await?;
        let file_path = dir_path.join(file_name);
        
        // ÂÜçÊ¨°È™åËØÅÊúÄÁªàÊñá‰ª∂Ë∑ØÂæÑ
        if !file_path.starts_with(&self.root) {
            return Err(anyhow::anyhow!("Êñá‰ª∂Ë∑ØÂæÑË∂ÖÂá∫Ê†πÁõÆÂΩïËåÉÂõ¥"));
        }
        
        tokio::fs::write(&file_path, content).await?;
        Ok(())
    }

    async fn delete(&self, path: &str) -> anyhow::Result<()> {
        let full_path = self.normalize_path(path)?;
        if full_path.exists() {
            if full_path.is_dir() {
                std::fs::remove_dir_all(full_path)?;
            } else {
                std::fs::remove_file(full_path)?;
            }
        }
        Ok(())
    }

    async fn rename(&self, old_path: &str, new_name: &str) -> anyhow::Result<()> {
        let old_full_path = self.normalize_path(old_path)?;
        let parent = old_full_path.parent()
            .ok_or_else(|| anyhow::anyhow!("Cannot get parent directory"))?;
        let new_full_path = parent.join(new_name);
        
        // È™åËØÅÊñ∞Ë∑ØÂæÑ
        if !new_full_path.starts_with(&self.root) {
            return Err(anyhow::anyhow!("Êñ∞Êñá‰ª∂Ë∑ØÂæÑË∂ÖÂá∫Ê†πÁõÆÂΩïËåÉÂõ¥"));
        }
        
        if old_full_path.exists() {
            std::fs::rename(old_full_path, new_full_path)?;
        }
        Ok(())
    }

    async fn create_folder(&self, parent_path: &str, folder_name: &str) -> anyhow::Result<()> {
        let folder_path = if parent_path.is_empty() {
            self.root.join(folder_name)
        } else {
            self.normalize_path(parent_path)?.join(folder_name)
        };
        
        // È™åËØÅÊñá‰ª∂Â§πË∑ØÂæÑ
        if !folder_path.starts_with(&self.root) {
            return Err(anyhow::anyhow!("Êñá‰ª∂Â§πË∑ØÂæÑË∂ÖÂá∫Ê†πÁõÆÂΩïËåÉÂõ¥"));
        }
        
        println!("üìÅ Êú¨Âú∞È©±Âä®ÂàõÂª∫Êñá‰ª∂Â§π: {:?}", folder_path);
        
        std::fs::create_dir_all(&folder_path)?;
        
        // È™åËØÅÊñá‰ª∂Â§πÊòØÂê¶ÂàõÂª∫ÊàêÂäü
        if folder_path.exists() {
            println!("‚úÖ Êñá‰ª∂Â§πÂàõÂª∫ÊàêÂäü: {:?}", folder_path);
        } else {
            println!("‚ùå Êñá‰ª∂Â§πÂàõÂª∫Â§±Ë¥•: {:?}", folder_path);
        }
        
        Ok(())
    }

    async fn get_file_info(&self, path: &str) -> anyhow::Result<FileInfo> {
        let full_path = self.normalize_path(path)?;
        let metadata = fs::metadata(&full_path).await?;
        
        let name = full_path.file_name()
            .map(|n| n.to_string_lossy().to_string())
            .unwrap_or_else(|| path.to_string());
        
        let is_dir = metadata.is_dir();
        let size = if is_dir { 0 } else { metadata.len() };
        let modified = metadata.modified()
            .map(|time| {
                let datetime: DateTime<Local> = time.into();
                datetime.to_rfc3339()
            })
            .unwrap_or_else(|_| chrono::Utc::now().to_rfc3339());

        Ok(FileInfo {
            name,
            path: path.to_string(),
            size,
            is_dir,
            modified,
        })
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
    
    // Êú¨Âú∞È©±Âä®ÊîØÊåÅÊµÅÂºè‰∏ãËΩΩ
    async fn stream_download(&self, path: &str) -> anyhow::Result<Option<(Box<dyn futures::Stream<Item = Result<axum::body::Bytes, std::io::Error>> + Send + Unpin>, String)>> {
        let full_path = self.root.join(path);
        let filename = full_path.file_name()
            .unwrap_or_else(|| std::ffi::OsStr::new("download"))
            .to_string_lossy()
            .to_string();
        
        println!("üåä Êú¨Âú∞ÊµÅÂºè‰∏ãËΩΩ: {:?}", full_path);
        
        // ÂàõÂª∫ÂºÇÊ≠•ÊµÅ
        let stream = async_stream::stream! {
            use tokio::io::AsyncReadExt;
            
            match tokio::fs::File::open(&full_path).await {
                Ok(mut file) => {
                    let mut buffer = [0u8; 8192]; // 8KB ÁºìÂÜ≤Âå∫
                    let mut total_bytes = 0u64;
                    
                    println!("üöÄ ÂºÄÂßãÊú¨Âú∞ÊµÅÂºè‰º†Ëæì");
                    
                    loop {
                        match file.read(&mut buffer).await {
                            Ok(0) => {
                                println!("‚úÖ Êú¨Âú∞ÊµÅÂºè‰º†ËæìÂÆåÊàêÔºåÂÖ± {} Â≠óËäÇ ({} MB)", 
                                    total_bytes, total_bytes / 1024 / 1024);
                                break;
                            },
                            Ok(n) => {
                                total_bytes += n as u64;
                                // ÊØè10MBËæìÂá∫‰∏ÄÊ¨°ËøõÂ∫¶
                                if total_bytes % (10 * 1024 * 1024) == 0 {
                                    println!("üìä Êú¨Âú∞ÊµÅÂºè‰º†ËæìËøõÂ∫¶: {} MB", total_bytes / 1024 / 1024);
                                }
                                yield Ok(axum::body::Bytes::copy_from_slice(&buffer[..n]));
                            },
                            Err(e) => {
                                println!("‚ùå Êú¨Âú∞ÊµÅÂºè‰º†ËæìÈîôËØØ: {}", e);
                                yield Err(e);
                                break;
            }
                        }
                    }
                },
            Err(e) => {
                    println!("‚ùå ÊâìÂºÄÊú¨Âú∞Êñá‰ª∂Â§±Ë¥•: {}", e);
                    yield Err(e);
                }
            }
        };
        
        let boxed_stream: Box<dyn futures::Stream<Item = Result<axum::body::Bytes, std::io::Error>> + Send + Unpin> = 
            Box::new(Box::pin(stream));
        
        Ok(Some((boxed_stream, filename)))
    }
    
    // Êú¨Âú∞È©±Âä®ÊîØÊåÅ Range ÊµÅÂºè‰∏ãËΩΩ
    async fn stream_download_with_range(&self, path: &str, start: Option<u64>, end: Option<u64>) -> anyhow::Result<Option<(Box<dyn futures::Stream<Item = Result<axum::body::Bytes, std::io::Error>> + Send + Unpin>, String, u64, Option<u64>)>> {
        let full_path = self.normalize_path(path)?;
        let filename = full_path.file_name()
            .unwrap_or_else(|| std::ffi::OsStr::new("download"))
            .to_string_lossy()
            .to_string();
        
        // Ëé∑ÂèñÊñá‰ª∂Â§ßÂ∞è
        let metadata = tokio::fs::metadata(&full_path).await?;
        let file_size = metadata.len();
        
        // ËÆ°ÁÆóÂÆûÈôÖÁöÑÂºÄÂßãÂíåÁªìÊùü‰ΩçÁΩÆ
        let actual_start = start.unwrap_or(0);
        let actual_end = end.unwrap_or(file_size - 1).min(file_size - 1);
        
        if actual_start >= file_size {
            return Err(anyhow::anyhow!("Range Ëµ∑Âßã‰ΩçÁΩÆË∂ÖÂá∫Êñá‰ª∂Â§ßÂ∞è"));
        }
        
        let content_length = actual_end - actual_start + 1;
        
        println!("üéØ Êú¨Âú∞ Range ‰∏ãËΩΩ: {:?} ({}:{}) Êñá‰ª∂Â§ßÂ∞è: {}", 
            full_path, actual_start, actual_end, file_size);
        
        // ÂàõÂª∫ÂºÇÊ≠•ÊµÅÔºåÊîØÊåÅ Range ËØ∑Ê±Ç
        let stream = async_stream::stream! {
            use tokio::io::{AsyncReadExt, AsyncSeekExt};
            
            match tokio::fs::File::open(&full_path).await {
                Ok(mut file) => {
                    // ÂÆö‰ΩçÂà∞Ëµ∑Âßã‰ΩçÁΩÆ
                    if let Err(e) = file.seek(std::io::SeekFrom::Start(actual_start)).await {
                        println!("‚ùå Êú¨Âú∞Êñá‰ª∂ÂÆö‰ΩçÂ§±Ë¥•: {}", e);
                        yield Err(std::io::Error::new(std::io::ErrorKind::Other, e));
                        return;
                    }
                    
                    let mut buffer = vec![0u8; 1024 * 1024]; // 1MB ÁºìÂÜ≤Âå∫
                    let mut bytes_read = 0u64;
                    let target_bytes = content_length;
                    
                    println!("üöÄ ÂºÄÂßãÊú¨Âú∞ Range ‰º†Ëæì: {} Â≠óËäÇ", target_bytes);
                    
                    while bytes_read < target_bytes {
                        let remaining = target_bytes - bytes_read;
                        let to_read = (buffer.len() as u64).min(remaining) as usize;
                        
                        match file.read(&mut buffer[..to_read]).await {
                            Ok(0) => {
                                println!("‚ö†Ô∏è Êú¨Âú∞Êñá‰ª∂ÊèêÂâçÁªìÊùüÔºåÂ∑≤ËØªÂèñ {} / {} Â≠óËäÇ", bytes_read, target_bytes);
                                break;
                            },
                            Ok(n) => {
                                bytes_read += n as u64;
                                // ÊØè10MBËæìÂá∫‰∏ÄÊ¨°ËøõÂ∫¶
                                if bytes_read % (10 * 1024 * 1024) == 0 {
                                    println!("üìä Êú¨Âú∞ Range ‰º†ËæìËøõÂ∫¶: {} / {} MB", 
                                        bytes_read / 1024 / 1024, target_bytes / 1024 / 1024);
                                }
                                yield Ok(axum::body::Bytes::copy_from_slice(&buffer[..n]));
                            },
                            Err(e) => {
                                println!("‚ùå Êú¨Âú∞ Range ‰º†ËæìÈîôËØØ: {}", e);
                                yield Err(e);
                                break;
                            }
                        }
                    }
                    
                    println!("‚úÖ Êú¨Âú∞ Range ‰º†ËæìÂÆåÊàê: {} / {} Â≠óËäÇ", bytes_read, target_bytes);
                },
                Err(e) => {
                    println!("‚ùå ÊâìÂºÄÊú¨Âú∞Êñá‰ª∂Â§±Ë¥•: {}", e);
                    yield Err(e);
                }
            }
        };
        
        let boxed_stream = Box::new(Box::pin(stream));
        
        Ok(Some((boxed_stream, filename, file_size, Some(content_length))))
    }
}

// Êú¨Âú∞È©±Âä®Â∑•ÂéÇ
pub struct LocalDriverFactory;

impl DriverFactory for LocalDriverFactory {
    fn driver_type(&self) -> &'static str {
        "local"
    }

    fn driver_info(&self) -> DriverInfo {
        DriverInfo {
            driver_type: "local".to_string(),
            display_name: "Êú¨Âú∞Â≠òÂÇ®".to_string(),
            description: "Êú¨Âú∞Êñá‰ª∂Á≥ªÁªüÂ≠òÂÇ®".to_string(),
            config_schema: serde_json::json!({
                "type": "object",
                "properties": {
                    "root": {
                        "type": "string",
                        "title": "Êú¨Âú∞Ë∑ØÂæÑ",
                        "description": "Â≠òÂÇ®Êñá‰ª∂ÁöÑÊú¨Âú∞ÁõÆÂΩïË∑ØÂæÑÔºà‰ΩøÁî®ÁªùÂØπË∑ØÂæÑÔºâ",
                        "placeholder": if cfg!(windows) { "E:/Storage" } else { "/opt/storage" }
                    }
                },
                "required": ["root"]
            }),
        }
    }

    fn create_driver(&self, config: serde_json::Value) -> anyhow::Result<Box<dyn Driver>> {
        let root = config.get("root")
            .and_then(|v| v.as_str())
            .ok_or_else(|| anyhow::anyhow!("Missing 'root' in local driver config"))?;

        // ËßÑËåÉÂåñÊ†πË∑ØÂæÑ
        let root_path = if cfg!(windows) {
            // Windows Ë∑ØÂæÑÂ§ÑÁêÜ
            PathBuf::from(root.replace('/', "\\"))
        } else {
            // Unix Ë∑ØÂæÑÂ§ÑÁêÜ
            PathBuf::from(root.replace('\\', "/"))
        };

        // Á°Æ‰øùÊòØÁªùÂØπË∑ØÂæÑ
        let root_path = if root_path.is_absolute() {
            root_path
        } else {
            env::current_dir()?.join(root_path)
        };

        // ÂàõÂª∫ÁõÆÂΩïÔºàÂ¶ÇÊûú‰∏çÂ≠òÂú®Ôºâ
        std::fs::create_dir_all(&root_path)?;

        // Ëé∑ÂèñËßÑËåÉÂåñÁöÑÁªùÂØπË∑ØÂæÑ
        let canonical_root = root_path.canonicalize()?;

        Ok(Box::new(LocalDriver {
            root: canonical_root,
        }))
    }

    fn get_routes(&self) -> Option<axum::Router> {
        None
    }
}
